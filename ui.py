import matplotlib.pyplot as plt
import networkx as nx
import time

from game import Game
from strategy import STRATEGIES

# Please do not edit this file.
# If you need additional functionality, open an issue on gitlab and create a new file in the meantime.

def draw_state(G, game, pos, ax, title=None):
    """
    Draw the current game state with special colors for start/endpoints.

    :param G: (nx.Graph) The graph representing the game field.
    :param game: (Game) The current game state.
    :param pos: (dict) A dictionary mapping node IDs to positions.
    :param ax: (matplotlib.axes.Axes) The matplotlib axes object to draw on.
    :param title: (str) Optional title for the plot.
    :return: None
    """
    ax.clear()

    snake0 = game.state.snakes[0]
    snake1 = game.state.snakes[1]

    start0 = snake0[0] if snake0 else None
    end0   = snake0[-1] if snake0 else None

    start1 = snake1[0] if snake1 else None
    end1   = snake1[-1] if snake1 else None

    colors = []
    for v in G.nodes():

        # --- PLAYER 0 (red) ---
        if v == start0:
            colors.append("#800000")  # dark red
        elif v == end0:
            colors.append("#ff0000")  # bright red
        elif v in snake0:
            colors.append("#ff8080")  # light red

        # --- PLAYER 1 (blue) ---
        elif v == start1:
            colors.append("#000080")  # dark blue
        elif v == end1:
            colors.append("#0000ff")  # bright blue
        elif v in snake1:
            colors.append("#8080ff")  # light blue

        # --- Unoccupied ---
        else:
            colors.append("lightgray")

    # Draw base edges
    nx.draw_networkx_edges(G, pos, ax=ax, width=1, alpha=0.4)

    # Draw nodes
    nx.draw_networkx_nodes(G, pos, ax=ax, node_color=colors, node_size=330)

    # Highlight snake edges
    edges_p0 = list(zip(snake0, snake0[1:]))
    edges_p1 = list(zip(snake1, snake1[1:]))

    nx.draw_networkx_edges(G, pos, ax=ax, edgelist=edges_p0, width=3, edge_color="red")
    nx.draw_networkx_edges(G, pos, ax=ax, edgelist=edges_p1, width=3, edge_color="blue")

    # Labels
    nx.draw_networkx_labels(G, pos, ax=ax)

    if title:
        ax.set_title(title)

    plt.pause(0.001)


def interactive_view(G_dict, start_a, start_b,
                     s0_name="random", s1_name="random",
                     pause=1):
    """
    Run a UI-based game between two strategies or two random AIs.
    Window stays open after game ends.

    :param G_dict: (dict) Adjacency dictionary representing the game field.
    :param start_a: (int) Starting position for player A as an integer node.
    :param start_b: (int) Starting position for player B as an integer node.
    :param s0_name: (str) Name of strategy for player A.
    :param s1_name: (str) Name of strategy for player B.
    :param pause: (float) Time in seconds to wait between each move.
    :return: (int) ID of the winner of the game.
    """
    # Build networkx graph from adjacency dictionary
    G = nx.Graph()
    for u, nbrs in G_dict.items():
        for v in nbrs:
            G.add_edge(u, v)

    pos = nx.spring_layout(G, seed=1)

    # Prepare window
    plt.ion()
    fig, ax = plt.subplots(figsize=(7, 7))

    # Load strategies
    s0 = STRATEGIES[s0_name]()
    s1 = STRATEGIES[s1_name]()
    strategies = {0: s0, 1: s1}

    # Start game
    game = Game(G_dict, start_a, start_b)
    current = 0
    winner = None

    draw_state(G, game, pos, ax, title="Start of the Game")
    time.sleep(pause)

    # Manual loop (not using play_game)
    while True:
        legal = game.legal_moves(current)
        if not legal:
            winner = 1 - current
            break

        move = strategies[current].select_move(game.state.copy(), current, legal)

        if move is None:
            winner = 1 - current
            break

        if move not in legal:
            raise ValueError(f"Strategy {current} returned illegal move {move}")

        game.apply(current, move)

        draw_state(G, game, pos, ax, title=f"Player {current} played {move}")
        time.sleep(pause)

        current = 1 - current

    # Game over
    draw_state(G, game, pos, ax, title=f"Game Over â€“ Winner: Player {winner}")

    plt.ioff()
    plt.show()

    return winner