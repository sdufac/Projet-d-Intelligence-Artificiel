from typing import Dict, Set, List, Iterable, Optional
from dataclasses import dataclass

# Please do not edit this file.
# It is very likely that you will require modifications to this file.
# If you need additional functionality, open an issue on gitlab and create a new file in the meantime.

@dataclass(frozen=True)
class Move:
    """
    Represents a move in the game from one node to another.
    """
    from_node: int
    to_node: int


class GameState:
    """
    Represents the current state of the game, including the positions of the snakes
    and the occupied nodes.
    """
    def __init__(self, nodes: Iterable[int], G: Dict[int, Set[int]]):
        """
        Initialize the game state.

        :param nodes: (Iterable[int]) The nodes in the graph.
        :param G: (Dict[int, Set[int]]) The adjacency dictionary for the graph.
        """
        self.nodes = set(nodes)
        self.G = G
        # Snakes are stored as list of nodes in order from head(start) to tail(current endpoint)
        self.snakes: Dict[int, List[int]] = {0: [], 1: []}
        self.endpoints: Dict[int, Optional[int]] = {0: None, 1: None}
        # Occupied nodes set
        self.occupied: Set[int] = set()

    def init_snakes(self, start_a: int, start_b: int):
        """
        Initialize the snakes with their starting positions.

        :param start_a: (int) Starting position for player A.
        :param start_b: (int) Starting position for player B.
        :return: (None)
        """
        if start_a == start_b:
            raise ValueError('Start nodes must be distinct')
        self.snakes[0] = [start_a]
        self.snakes[1] = [start_b]
        self.endpoints[0] = start_a
        self.endpoints[1] = start_b
        self.occupied = {start_a, start_b}

    def copy(self):
        """
        Create a deep copy of the current game state.

        :return: (GameState) A deep copy of the current game state.
        """
        import copy as _c
        new = GameState(self.nodes, self.G)
        new.snakes = _c.deepcopy(self.snakes)
        new.endpoints = dict(self.endpoints)
        new.occupied = set(self.occupied)
        return new


# Rule checks

def _check_induced_path_property(occupied: Set[int], G: Dict[int, Set[int]]) -> bool:
    """
    Check that the occupied nodes form induced paths (no node has more than 2 occupied neighbors).

    :param occupied: (Set[int]) The set of occupied nodes.
    :param G: (Dict[int, Set[int]]) The adjacency dictionary for the graph.
    :return: (bool) True if the induced path property holds, False otherwise.
    """
    for v in occupied:
        cnt = sum(1 for u in G[v] if u in occupied)
        if cnt > 2:
            return False
    return True


def is_move_legal(state: GameState, player: int, move: Move) -> bool:
    """
    Check if a move is legal according to the game rules.

    :param state: (GameState) The current game state.
    :param player: (int) The ID of the current player, 0 or 1.
    :param move: (Move) The move to check.
    :return: (bool) True if the move is legal, False otherwise.
    """
    # Basic checks: move.from_node must be the current head of the snake
    if state.endpoints[player] != move.from_node:
        return False
    # Basic checks: the intended new node to_node must not be already occupied
    if move.to_node in state.occupied:
        return False
    #  Basic checks: the intended new note to_node must be neighbor of the head of the snake
    if move.to_node not in state.G[move.from_node]:
        return False
    # Simulate the move and check the induced path property
    new_occupied = set(state.occupied)
    new_occupied.add(move.to_node)
    # Update adjacency for snake endpoints: note that interior nodes were already adjacent
    return _check_induced_path_property(new_occupied, state.G)


def apply_move(state: GameState, player: int, move: Move) -> None:
    """
    Apply a move to the game state.

    :param state: (GameState) The current game state.
    :param player: (int) The ID of the current player, 0 or 1.
    :param move: (Move) The move to apply.
    :return: (None)
    """
    # We assume here that the move is legal; legality should be checked before calling this function
    state.snakes[player].append(move.to_node)
    state.endpoints[player] = move.to_node
    state.occupied.add(move.to_node)
