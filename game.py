from typing import List, Tuple, Optional, Set, Dict
import copy

from logic import is_move_legal, apply_move, GameState, Move

# Please do not edit this file.
# If you need additional functionality, open an issue on gitlab and create a new file in the meantime.

class Game:
    """
    Game engine for the two-player snake-in-the-box game.

    State representation is kept in logic.GameState (imported). This engine
    handles turn-taking, game loop, and simple referee services.
    """

    def __init__(self, G: Dict[int, Set[int]], start_a: int, start_b: int):
        """
        Initializes the game with the provided graph, starting positions for the players,
        and sets up the game state and other parameters. This includes setting the graph
        as the playing field, initializing the current game state, and defining the history
        of moves and the winner of the game.

        :param G: (Dict[int, Set[int]]) A dictionary representing the graph.
        Keys are nodes (int) and values are sets of integers representing the adjacent nodes.
        :param start_a: (int) Starting position for player A as an integer node.
        :param start_b: (int) Starting position for player B as an integer node.
        """
        self.G = G
        self.n = len(G)
        self.state = GameState(self.G.keys(), G)
        self.state.init_snakes(start_a, start_b)
        self.history: List[Tuple[int, Move]] = []  # (player, move)
        self.winner: Optional[int] = None

    def legal_moves(self, player: int) -> List[Move]:
        """
        Determines and returns a list of legal moves for the specified player.

        :param player: (int) ID of the current player, 0 or 1.
        :return: (List[Move]) A list of legal moves available to the given player, adhering
                 to the game's legality constraints.
        """
        return [m for m in self._candidate_moves(player) if is_move_legal(self.state, player, m)]

    def _candidate_moves(self, player: int) -> List[Move]:
        """
        Generate all candidate moves for the given player based on the current endpoint.

        :param player: (int) ID of the current player, 0 or 1.
        :return: (List[Move]) A list of candidate moves, regardless of whether they are legal or not.
        """
        endpoint = self.state.endpoints[player]
        if endpoint is None:
            return []
        return [Move(from_node=endpoint, to_node=v) for v in self.G[endpoint] if v not in self.state.occupied]

    def apply(self, player: int, move: Move) -> bool:
        """
        Applies the specified move for the given player if it is legal.

        :param player: (int) ID of the current player, 0 or 1.
        :param move: (Move) The move to apply.
        :return: (bool) True if the move was applied successfully, False otherwise.
        """

        if not is_move_legal(self.state, player, move):
            raise ValueError(f"Illegal move by player {player}: {move}")
        apply_move(self.state, player, move)
        self.history.append((player, move))

        # Check if the next player has any legal moves left
        next_player = 1 - player
        if len(self.legal_moves(next_player)) == 0:
            self.winner = player
        return True

    def is_over(self) -> bool:
        # Only consider the game over if a winner has been assigned.
        # Whether a player has no legal moves is turn-dependent and must
        # be handled by the game loop that knows whose turn it is.
        return self.winner is not None

    def play_game(self, strategy0, strategy1, verbose=False, max_moves=10000):
        """
        Play a full game between two strategies.

        :param strategy0: (Strategy) The strategy for player 0.
        :param strategy1: (Strategy) The strategy for player 1.
        :param verbose: (bool) Whether to print moves as they are played.
        :param max_moves: (int) Maximum number of moves to play before timing out.
        :return: (int) The ID of the winner of the game.
        """

        strategies = {0: strategy0, 1: strategy1}
        cur = 0
        moves = 0
        while moves < max_moves:
            if self.winner is not None:
                break
            legal = self.legal_moves(cur)
            if not legal:
                # current player cannot move -> loses
                self.winner = 1 - cur
                break
            move = strategies[cur].select_move(copy.deepcopy(self.state), cur, legal)
            # allow strategies to return None => resign
            if move is None:
                self.winner = 1 - cur
                break
            if move not in legal:
                # learners might return illegal moves; treat as immediate loss
                raise ValueError(f"Strategy returned illegal move: {move}")
            self.apply(cur, move)
            if verbose:
                print(f"Player {cur} plays {move}")
            cur = 1 - cur
            moves += 1
        if self.winner is None:
            # tie-break: player with more snake length wins, else first-player.
            # This should never occur in practice; just here as a safeguard to avoid any None winner.
            len0 = len(self.state.snakes[0])
            len1 = len(self.state.snakes[1])
            if len0 != len1:
                self.winner = 0 if len0 > len1 else 1
            else:
                self.winner = 0
        return self.winner
